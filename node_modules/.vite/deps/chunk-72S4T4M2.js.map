{
  "version": 3,
  "sources": ["../../src/splitter/style/SplitterStyle.js", "../../src/splitter/BaseSplitter.vue", "../../src/splitter/Splitter.vue", "../../src/splitter/Splitter.vue?vue&type=template&id=92aa5fd8&lang.js"],
  "sourcesContent": ["import { style } from '@primeuix/styles/splitter';\nimport BaseStyle from '@primevue/core/base/style';\n\nconst classes = {\n    root: ({ props }) => ['p-splitter p-component', 'p-splitter-' + props.layout],\n    gutter: 'p-splitter-gutter',\n    gutterHandle: 'p-splitter-gutter-handle'\n};\n\nexport default BaseStyle.extend({\n    name: 'splitter',\n    style,\n    classes\n});\n", "<script>\nimport BaseComponent from '@primevue/core/basecomponent';\nimport SplitterStyle from 'primevue/splitter/style';\n\nexport default {\n    name: 'BaseSplitter',\n    extends: BaseComponent,\n    props: {\n        layout: {\n            type: String,\n            default: 'horizontal'\n        },\n        gutterSize: {\n            type: Number,\n            default: 4\n        },\n        stateKey: {\n            type: String,\n            default: null\n        },\n        stateStorage: {\n            type: String,\n            default: 'session'\n        },\n        step: {\n            type: Number,\n            default: 5\n        }\n    },\n    style: SplitterStyle,\n    provide() {\n        return {\n            $pcSplitter: this,\n            $parentInstance: this\n        };\n    }\n};\n</script>\n", "<template>\n    <div :class=\"cx('root')\" :data-p-resizing=\"false\" :data-p=\"dataP\" v-bind=\"ptmi('root', getPTOptions)\">\n        <template v-for=\"(panel, i) of panels\" :key=\"i\">\n            <component :is=\"panel\" tabindex=\"-1\"></component>\n            <div\n                v-if=\"i !== panels.length - 1\"\n                ref=\"gutter\"\n                :class=\"cx('gutter')\"\n                role=\"separator\"\n                tabindex=\"-1\"\n                @mousedown=\"onGutterMouseDown($event, i)\"\n                @touchstart=\"onGutterTouchStart($event, i)\"\n                @touchmove=\"onGutterTouchMove($event, i)\"\n                @touchend=\"onGutterTouchEnd($event, i)\"\n                :data-p-gutter-resizing=\"false\"\n                :data-p=\"dataP\"\n                v-bind=\"ptm('gutter')\"\n            >\n                <div :class=\"cx('gutterHandle')\" tabindex=\"0\" :style=\"[gutterStyle]\" :aria-orientation=\"layout\" :aria-valuenow=\"prevSize\" @keyup=\"onGutterKeyUp\" @keydown=\"onGutterKeyDown($event, i)\" :data-p=\"dataP\" v-bind=\"ptm('gutterHandle')\"></div>\n            </div>\n        </template>\n    </div>\n</template>\n\n<script>\nimport { cn } from '@primeuix/utils';\nimport { getHeight, getOuterHeight, getOuterWidth, getWidth, isRTL } from '@primeuix/utils/dom';\nimport { isArray, isNotEmpty } from '@primeuix/utils/object';\nimport { getVNodeProp } from '@primevue/core/utils';\nimport BaseSplitter from './BaseSplitter.vue';\n\nexport default {\n    name: 'Splitter',\n    extends: BaseSplitter,\n    inheritAttrs: false,\n    emits: ['resizestart', 'resizeend', 'resize'],\n    dragging: false,\n    mouseMoveListener: null,\n    mouseUpListener: null,\n    touchMoveListener: null,\n    touchEndListener: null,\n    size: null,\n    gutterElement: null,\n    startPos: null,\n    prevPanelElement: null,\n    nextPanelElement: null,\n    nextPanelSize: null,\n    prevPanelSize: null,\n    panelSizes: null,\n    prevPanelIndex: null,\n    timer: null,\n    data() {\n        return {\n            prevSize: null\n        };\n    },\n    mounted() {\n        this.initializePanels();\n    },\n    beforeUnmount() {\n        this.clear();\n        this.unbindMouseListeners();\n    },\n    methods: {\n        isSplitterPanel(child) {\n            return child.type.name === 'SplitterPanel';\n        },\n        initializePanels() {\n            if (this.panels && this.panels.length) {\n                let initialized = false;\n\n                if (this.isStateful()) {\n                    initialized = this.restoreState();\n                }\n\n                if (!initialized) {\n                    let children = [...this.$el.children].filter((child) => child.getAttribute('data-pc-name') === 'splitterpanel');\n                    let _panelSizes = [];\n\n                    this.panels.map((panel, i) => {\n                        let panelInitialSize = panel.props && isNotEmpty(panel.props.size) ? panel.props.size : null;\n                        let panelSize = panelInitialSize ?? 100 / this.panels.length;\n\n                        _panelSizes[i] = panelSize;\n                        children[i].style.flexBasis = 'calc(' + panelSize + '% - ' + (this.panels.length - 1) * this.gutterSize + 'px)';\n                    });\n\n                    this.panelSizes = _panelSizes;\n                    this.prevSize = parseFloat(_panelSizes[0]).toFixed(4);\n                }\n            }\n        },\n        onResizeStart(event, index, isKeyDown) {\n            this.gutterElement = event.currentTarget || event.target.parentElement;\n            this.size = this.horizontal ? getWidth(this.$el) : getHeight(this.$el);\n\n            if (!isKeyDown) {\n                this.dragging = true;\n                this.startPos = this.layout === 'horizontal' ? event.pageX || event.changedTouches[0].pageX : event.pageY || event.changedTouches[0].pageY;\n            }\n\n            this.prevPanelElement = this.gutterElement.previousElementSibling;\n            this.nextPanelElement = this.gutterElement.nextElementSibling;\n\n            if (isKeyDown) {\n                this.prevPanelSize = this.horizontal ? getOuterWidth(this.prevPanelElement, true) : getOuterHeight(this.prevPanelElement, true);\n                this.nextPanelSize = this.horizontal ? getOuterWidth(this.nextPanelElement, true) : getOuterHeight(this.nextPanelElement, true);\n            } else {\n                this.prevPanelSize = (100 * (this.horizontal ? getOuterWidth(this.prevPanelElement, true) : getOuterHeight(this.prevPanelElement, true))) / this.size;\n                this.nextPanelSize = (100 * (this.horizontal ? getOuterWidth(this.nextPanelElement, true) : getOuterHeight(this.nextPanelElement, true))) / this.size;\n            }\n\n            this.prevPanelIndex = index;\n            this.$emit('resizestart', { originalEvent: event, sizes: this.panelSizes });\n            this.$refs.gutter[index].setAttribute('data-p-gutter-resizing', true);\n            this.$el.setAttribute('data-p-resizing', true);\n        },\n        onResize(event, step, isKeyDown) {\n            let newPos, newPrevPanelSize, newNextPanelSize;\n\n            if (isKeyDown) {\n                if (this.horizontal) {\n                    newPrevPanelSize = (100 * (this.prevPanelSize + step)) / this.size;\n                    newNextPanelSize = (100 * (this.nextPanelSize - step)) / this.size;\n                } else {\n                    newPrevPanelSize = (100 * (this.prevPanelSize - step)) / this.size;\n                    newNextPanelSize = (100 * (this.nextPanelSize + step)) / this.size;\n                }\n            } else {\n                if (this.horizontal) {\n                    if (isRTL(this.$el)) {\n                        newPos = ((this.startPos - event.pageX) * 100) / this.size;\n                    } else {\n                        newPos = ((event.pageX - this.startPos) * 100) / this.size;\n                    }\n                } else {\n                    newPos = ((event.pageY - this.startPos) * 100) / this.size;\n                }\n\n                newPrevPanelSize = this.prevPanelSize + newPos;\n                newNextPanelSize = this.nextPanelSize - newPos;\n            }\n\n            if (!this.validateResize(newPrevPanelSize, newNextPanelSize)) {\n                newPrevPanelSize = Math.min(Math.max(this.prevPanelMinSize, newPrevPanelSize), 100 - this.nextPanelMinSize);\n                newNextPanelSize = Math.min(Math.max(this.nextPanelMinSize, newNextPanelSize), 100 - this.prevPanelMinSize);\n            }\n\n            this.prevPanelElement.style.flexBasis = 'calc(' + newPrevPanelSize + '% - ' + (this.panels.length - 1) * this.gutterSize + 'px)';\n            this.nextPanelElement.style.flexBasis = 'calc(' + newNextPanelSize + '% - ' + (this.panels.length - 1) * this.gutterSize + 'px)';\n            this.panelSizes[this.prevPanelIndex] = newPrevPanelSize;\n            this.panelSizes[this.prevPanelIndex + 1] = newNextPanelSize;\n            this.prevSize = parseFloat(newPrevPanelSize).toFixed(4);\n\n            this.$emit('resize', { originalEvent: event, sizes: this.panelSizes });\n        },\n        onResizeEnd(event) {\n            if (this.isStateful()) {\n                this.saveState();\n            }\n\n            this.$emit('resizeend', { originalEvent: event, sizes: this.panelSizes });\n            this.$refs.gutter.forEach((gutter) => gutter.setAttribute('data-p-gutter-resizing', false));\n            this.$el.setAttribute('data-p-resizing', false);\n            this.clear();\n        },\n        repeat(event, index, step) {\n            this.onResizeStart(event, index, true);\n            this.onResize(event, step, true);\n        },\n        setTimer(event, index, step) {\n            if (!this.timer) {\n                this.timer = setInterval(() => {\n                    this.repeat(event, index, step);\n                }, 40);\n            }\n        },\n        clearTimer() {\n            if (this.timer) {\n                clearInterval(this.timer);\n                this.timer = null;\n            }\n        },\n        onGutterKeyUp() {\n            this.clearTimer();\n            this.onResizeEnd();\n        },\n        onGutterKeyDown(event, index) {\n            switch (event.code) {\n                case 'ArrowLeft': {\n                    if (this.layout === 'horizontal') {\n                        this.setTimer(event, index, this.step * -1);\n                    }\n\n                    event.preventDefault();\n                    break;\n                }\n\n                case 'ArrowRight': {\n                    if (this.layout === 'horizontal') {\n                        this.setTimer(event, index, this.step);\n                    }\n\n                    event.preventDefault();\n                    break;\n                }\n\n                case 'ArrowDown': {\n                    if (this.layout === 'vertical') {\n                        this.setTimer(event, index, this.step * -1);\n                    }\n\n                    event.preventDefault();\n                    break;\n                }\n\n                case 'ArrowUp': {\n                    if (this.layout === 'vertical') {\n                        this.setTimer(event, index, this.step);\n                    }\n\n                    event.preventDefault();\n                    break;\n                }\n\n                default:\n                    //no op\n                    break;\n            }\n        },\n        onGutterMouseDown(event, index) {\n            this.onResizeStart(event, index);\n            this.bindMouseListeners();\n        },\n        onGutterTouchStart(event, index) {\n            this.onResizeStart(event, index);\n            this.bindTouchListeners();\n            event.preventDefault();\n        },\n        onGutterTouchMove(event) {\n            this.onResize(event);\n            event.preventDefault();\n        },\n        onGutterTouchEnd(event) {\n            this.onResizeEnd(event);\n            this.unbindTouchListeners();\n            event.preventDefault();\n        },\n        bindMouseListeners() {\n            if (!this.mouseMoveListener) {\n                this.mouseMoveListener = (event) => this.onResize(event);\n                document.addEventListener('mousemove', this.mouseMoveListener);\n            }\n\n            if (!this.mouseUpListener) {\n                this.mouseUpListener = (event) => {\n                    this.onResizeEnd(event);\n                    this.unbindMouseListeners();\n                };\n\n                document.addEventListener('mouseup', this.mouseUpListener);\n            }\n        },\n        bindTouchListeners() {\n            if (!this.touchMoveListener) {\n                this.touchMoveListener = (event) => this.onResize(event.changedTouches[0]);\n                document.addEventListener('touchmove', this.touchMoveListener);\n            }\n\n            if (!this.touchEndListener) {\n                this.touchEndListener = (event) => {\n                    this.resizeEnd(event);\n                    this.unbindTouchListeners();\n                };\n\n                document.addEventListener('touchend', this.touchEndListener);\n            }\n        },\n        validateResize(newPrevPanelSize, newNextPanelSize) {\n            if (newPrevPanelSize > 100 || newPrevPanelSize < 0) return false;\n            if (newNextPanelSize > 100 || newNextPanelSize < 0) return false;\n\n            if (this.prevPanelMinSize > newPrevPanelSize) {\n                return false;\n            }\n\n            if (this.nextPanelMinSize > newNextPanelSize) {\n                return false;\n            }\n\n            return true;\n        },\n        unbindMouseListeners() {\n            if (this.mouseMoveListener) {\n                document.removeEventListener('mousemove', this.mouseMoveListener);\n                this.mouseMoveListener = null;\n            }\n\n            if (this.mouseUpListener) {\n                document.removeEventListener('mouseup', this.mouseUpListener);\n                this.mouseUpListener = null;\n            }\n        },\n        unbindTouchListeners() {\n            if (this.touchMoveListener) {\n                document.removeEventListener('touchmove', this.touchMoveListener);\n                this.touchMoveListener = null;\n            }\n\n            if (this.touchEndListener) {\n                document.removeEventListener('touchend', this.touchEndListener);\n                this.touchEndListener = null;\n            }\n        },\n        clear() {\n            this.dragging = false;\n            this.size = null;\n            this.startPos = null;\n            this.prevPanelElement = null;\n            this.nextPanelElement = null;\n            this.prevPanelSize = null;\n            this.nextPanelSize = null;\n            this.gutterElement = null;\n            this.prevPanelIndex = null;\n        },\n        isStateful() {\n            return this.stateKey != null;\n        },\n        getStorage() {\n            switch (this.stateStorage) {\n                case 'local':\n                    return window.localStorage;\n\n                case 'session':\n                    return window.sessionStorage;\n\n                default:\n                    throw new Error(this.stateStorage + ' is not a valid value for the state storage, supported values are \"local\" and \"session\".');\n            }\n        },\n        saveState() {\n            if (isArray(this.panelSizes)) {\n                this.getStorage().setItem(this.stateKey, JSON.stringify(this.panelSizes));\n            }\n        },\n        restoreState() {\n            const storage = this.getStorage();\n            const stateString = storage.getItem(this.stateKey);\n\n            if (stateString) {\n                this.panelSizes = JSON.parse(stateString);\n                let children = [...this.$el.children].filter((child) => child.getAttribute('data-pc-name') === 'splitterpanel');\n\n                children.forEach((child, i) => {\n                    child.style.flexBasis = 'calc(' + this.panelSizes[i] + '% - ' + (this.panels.length - 1) * this.gutterSize + 'px)';\n                });\n\n                return true;\n            }\n\n            return false;\n        },\n        resetState() {\n            this.initializePanels();\n        }\n    },\n    computed: {\n        panels() {\n            const panels = [];\n\n            this.$slots.default().forEach((child) => {\n                if (this.isSplitterPanel(child)) {\n                    panels.push(child);\n                } else if (child.children instanceof Array) {\n                    child.children.forEach((nestedChild) => {\n                        if (this.isSplitterPanel(nestedChild)) {\n                            panels.push(nestedChild);\n                        }\n                    });\n                }\n            });\n\n            return panels;\n        },\n        gutterStyle() {\n            if (this.horizontal) return { width: this.gutterSize + 'px' };\n            else return { height: this.gutterSize + 'px' };\n        },\n        horizontal() {\n            return this.layout === 'horizontal';\n        },\n        getPTOptions() {\n            return {\n                context: {\n                    nested: this.$parentInstance?.nestedState\n                }\n            };\n        },\n        prevPanelMinSize() {\n            const prevPanelMinSize = getVNodeProp(this.panels[this.prevPanelIndex], 'minSize');\n\n            if (this.panels[this.prevPanelIndex].props && prevPanelMinSize) {\n                return prevPanelMinSize;\n            }\n\n            return 0;\n        },\n        nextPanelMinSize() {\n            const nextPanelMinSize = getVNodeProp(this.panels[this.prevPanelIndex + 1], 'minSize');\n\n            if (this.panels[this.prevPanelIndex + 1].props && nextPanelMinSize) {\n                return nextPanelMinSize;\n            }\n\n            return 0;\n        },\n        dataP() {\n            return cn({\n                [this.layout]: this.layout,\n                nested: this.$parentInstance?.nestedState != null\n            });\n        }\n    }\n};\n</script>\n", "<template>\n    <div :class=\"cx('root')\" :data-p-resizing=\"false\" :data-p=\"dataP\" v-bind=\"ptmi('root', getPTOptions)\">\n        <template v-for=\"(panel, i) of panels\" :key=\"i\">\n            <component :is=\"panel\" tabindex=\"-1\"></component>\n            <div\n                v-if=\"i !== panels.length - 1\"\n                ref=\"gutter\"\n                :class=\"cx('gutter')\"\n                role=\"separator\"\n                tabindex=\"-1\"\n                @mousedown=\"onGutterMouseDown($event, i)\"\n                @touchstart=\"onGutterTouchStart($event, i)\"\n                @touchmove=\"onGutterTouchMove($event, i)\"\n                @touchend=\"onGutterTouchEnd($event, i)\"\n                :data-p-gutter-resizing=\"false\"\n                :data-p=\"dataP\"\n                v-bind=\"ptm('gutter')\"\n            >\n                <div :class=\"cx('gutterHandle')\" tabindex=\"0\" :style=\"[gutterStyle]\" :aria-orientation=\"layout\" :aria-valuenow=\"prevSize\" @keyup=\"onGutterKeyUp\" @keydown=\"onGutterKeyDown($event, i)\" :data-p=\"dataP\" v-bind=\"ptm('gutterHandle')\"></div>\n            </div>\n        </template>\n    </div>\n</template>\n\n<script>\nimport { cn } from '@primeuix/utils';\nimport { getHeight, getOuterHeight, getOuterWidth, getWidth, isRTL } from '@primeuix/utils/dom';\nimport { isArray, isNotEmpty } from '@primeuix/utils/object';\nimport { getVNodeProp } from '@primevue/core/utils';\nimport BaseSplitter from './BaseSplitter.vue';\n\nexport default {\n    name: 'Splitter',\n    extends: BaseSplitter,\n    inheritAttrs: false,\n    emits: ['resizestart', 'resizeend', 'resize'],\n    dragging: false,\n    mouseMoveListener: null,\n    mouseUpListener: null,\n    touchMoveListener: null,\n    touchEndListener: null,\n    size: null,\n    gutterElement: null,\n    startPos: null,\n    prevPanelElement: null,\n    nextPanelElement: null,\n    nextPanelSize: null,\n    prevPanelSize: null,\n    panelSizes: null,\n    prevPanelIndex: null,\n    timer: null,\n    data() {\n        return {\n            prevSize: null\n        };\n    },\n    mounted() {\n        this.initializePanels();\n    },\n    beforeUnmount() {\n        this.clear();\n        this.unbindMouseListeners();\n    },\n    methods: {\n        isSplitterPanel(child) {\n            return child.type.name === 'SplitterPanel';\n        },\n        initializePanels() {\n            if (this.panels && this.panels.length) {\n                let initialized = false;\n\n                if (this.isStateful()) {\n                    initialized = this.restoreState();\n                }\n\n                if (!initialized) {\n                    let children = [...this.$el.children].filter((child) => child.getAttribute('data-pc-name') === 'splitterpanel');\n                    let _panelSizes = [];\n\n                    this.panels.map((panel, i) => {\n                        let panelInitialSize = panel.props && isNotEmpty(panel.props.size) ? panel.props.size : null;\n                        let panelSize = panelInitialSize ?? 100 / this.panels.length;\n\n                        _panelSizes[i] = panelSize;\n                        children[i].style.flexBasis = 'calc(' + panelSize + '% - ' + (this.panels.length - 1) * this.gutterSize + 'px)';\n                    });\n\n                    this.panelSizes = _panelSizes;\n                    this.prevSize = parseFloat(_panelSizes[0]).toFixed(4);\n                }\n            }\n        },\n        onResizeStart(event, index, isKeyDown) {\n            this.gutterElement = event.currentTarget || event.target.parentElement;\n            this.size = this.horizontal ? getWidth(this.$el) : getHeight(this.$el);\n\n            if (!isKeyDown) {\n                this.dragging = true;\n                this.startPos = this.layout === 'horizontal' ? event.pageX || event.changedTouches[0].pageX : event.pageY || event.changedTouches[0].pageY;\n            }\n\n            this.prevPanelElement = this.gutterElement.previousElementSibling;\n            this.nextPanelElement = this.gutterElement.nextElementSibling;\n\n            if (isKeyDown) {\n                this.prevPanelSize = this.horizontal ? getOuterWidth(this.prevPanelElement, true) : getOuterHeight(this.prevPanelElement, true);\n                this.nextPanelSize = this.horizontal ? getOuterWidth(this.nextPanelElement, true) : getOuterHeight(this.nextPanelElement, true);\n            } else {\n                this.prevPanelSize = (100 * (this.horizontal ? getOuterWidth(this.prevPanelElement, true) : getOuterHeight(this.prevPanelElement, true))) / this.size;\n                this.nextPanelSize = (100 * (this.horizontal ? getOuterWidth(this.nextPanelElement, true) : getOuterHeight(this.nextPanelElement, true))) / this.size;\n            }\n\n            this.prevPanelIndex = index;\n            this.$emit('resizestart', { originalEvent: event, sizes: this.panelSizes });\n            this.$refs.gutter[index].setAttribute('data-p-gutter-resizing', true);\n            this.$el.setAttribute('data-p-resizing', true);\n        },\n        onResize(event, step, isKeyDown) {\n            let newPos, newPrevPanelSize, newNextPanelSize;\n\n            if (isKeyDown) {\n                if (this.horizontal) {\n                    newPrevPanelSize = (100 * (this.prevPanelSize + step)) / this.size;\n                    newNextPanelSize = (100 * (this.nextPanelSize - step)) / this.size;\n                } else {\n                    newPrevPanelSize = (100 * (this.prevPanelSize - step)) / this.size;\n                    newNextPanelSize = (100 * (this.nextPanelSize + step)) / this.size;\n                }\n            } else {\n                if (this.horizontal) {\n                    if (isRTL(this.$el)) {\n                        newPos = ((this.startPos - event.pageX) * 100) / this.size;\n                    } else {\n                        newPos = ((event.pageX - this.startPos) * 100) / this.size;\n                    }\n                } else {\n                    newPos = ((event.pageY - this.startPos) * 100) / this.size;\n                }\n\n                newPrevPanelSize = this.prevPanelSize + newPos;\n                newNextPanelSize = this.nextPanelSize - newPos;\n            }\n\n            if (!this.validateResize(newPrevPanelSize, newNextPanelSize)) {\n                newPrevPanelSize = Math.min(Math.max(this.prevPanelMinSize, newPrevPanelSize), 100 - this.nextPanelMinSize);\n                newNextPanelSize = Math.min(Math.max(this.nextPanelMinSize, newNextPanelSize), 100 - this.prevPanelMinSize);\n            }\n\n            this.prevPanelElement.style.flexBasis = 'calc(' + newPrevPanelSize + '% - ' + (this.panels.length - 1) * this.gutterSize + 'px)';\n            this.nextPanelElement.style.flexBasis = 'calc(' + newNextPanelSize + '% - ' + (this.panels.length - 1) * this.gutterSize + 'px)';\n            this.panelSizes[this.prevPanelIndex] = newPrevPanelSize;\n            this.panelSizes[this.prevPanelIndex + 1] = newNextPanelSize;\n            this.prevSize = parseFloat(newPrevPanelSize).toFixed(4);\n\n            this.$emit('resize', { originalEvent: event, sizes: this.panelSizes });\n        },\n        onResizeEnd(event) {\n            if (this.isStateful()) {\n                this.saveState();\n            }\n\n            this.$emit('resizeend', { originalEvent: event, sizes: this.panelSizes });\n            this.$refs.gutter.forEach((gutter) => gutter.setAttribute('data-p-gutter-resizing', false));\n            this.$el.setAttribute('data-p-resizing', false);\n            this.clear();\n        },\n        repeat(event, index, step) {\n            this.onResizeStart(event, index, true);\n            this.onResize(event, step, true);\n        },\n        setTimer(event, index, step) {\n            if (!this.timer) {\n                this.timer = setInterval(() => {\n                    this.repeat(event, index, step);\n                }, 40);\n            }\n        },\n        clearTimer() {\n            if (this.timer) {\n                clearInterval(this.timer);\n                this.timer = null;\n            }\n        },\n        onGutterKeyUp() {\n            this.clearTimer();\n            this.onResizeEnd();\n        },\n        onGutterKeyDown(event, index) {\n            switch (event.code) {\n                case 'ArrowLeft': {\n                    if (this.layout === 'horizontal') {\n                        this.setTimer(event, index, this.step * -1);\n                    }\n\n                    event.preventDefault();\n                    break;\n                }\n\n                case 'ArrowRight': {\n                    if (this.layout === 'horizontal') {\n                        this.setTimer(event, index, this.step);\n                    }\n\n                    event.preventDefault();\n                    break;\n                }\n\n                case 'ArrowDown': {\n                    if (this.layout === 'vertical') {\n                        this.setTimer(event, index, this.step * -1);\n                    }\n\n                    event.preventDefault();\n                    break;\n                }\n\n                case 'ArrowUp': {\n                    if (this.layout === 'vertical') {\n                        this.setTimer(event, index, this.step);\n                    }\n\n                    event.preventDefault();\n                    break;\n                }\n\n                default:\n                    //no op\n                    break;\n            }\n        },\n        onGutterMouseDown(event, index) {\n            this.onResizeStart(event, index);\n            this.bindMouseListeners();\n        },\n        onGutterTouchStart(event, index) {\n            this.onResizeStart(event, index);\n            this.bindTouchListeners();\n            event.preventDefault();\n        },\n        onGutterTouchMove(event) {\n            this.onResize(event);\n            event.preventDefault();\n        },\n        onGutterTouchEnd(event) {\n            this.onResizeEnd(event);\n            this.unbindTouchListeners();\n            event.preventDefault();\n        },\n        bindMouseListeners() {\n            if (!this.mouseMoveListener) {\n                this.mouseMoveListener = (event) => this.onResize(event);\n                document.addEventListener('mousemove', this.mouseMoveListener);\n            }\n\n            if (!this.mouseUpListener) {\n                this.mouseUpListener = (event) => {\n                    this.onResizeEnd(event);\n                    this.unbindMouseListeners();\n                };\n\n                document.addEventListener('mouseup', this.mouseUpListener);\n            }\n        },\n        bindTouchListeners() {\n            if (!this.touchMoveListener) {\n                this.touchMoveListener = (event) => this.onResize(event.changedTouches[0]);\n                document.addEventListener('touchmove', this.touchMoveListener);\n            }\n\n            if (!this.touchEndListener) {\n                this.touchEndListener = (event) => {\n                    this.resizeEnd(event);\n                    this.unbindTouchListeners();\n                };\n\n                document.addEventListener('touchend', this.touchEndListener);\n            }\n        },\n        validateResize(newPrevPanelSize, newNextPanelSize) {\n            if (newPrevPanelSize > 100 || newPrevPanelSize < 0) return false;\n            if (newNextPanelSize > 100 || newNextPanelSize < 0) return false;\n\n            if (this.prevPanelMinSize > newPrevPanelSize) {\n                return false;\n            }\n\n            if (this.nextPanelMinSize > newNextPanelSize) {\n                return false;\n            }\n\n            return true;\n        },\n        unbindMouseListeners() {\n            if (this.mouseMoveListener) {\n                document.removeEventListener('mousemove', this.mouseMoveListener);\n                this.mouseMoveListener = null;\n            }\n\n            if (this.mouseUpListener) {\n                document.removeEventListener('mouseup', this.mouseUpListener);\n                this.mouseUpListener = null;\n            }\n        },\n        unbindTouchListeners() {\n            if (this.touchMoveListener) {\n                document.removeEventListener('touchmove', this.touchMoveListener);\n                this.touchMoveListener = null;\n            }\n\n            if (this.touchEndListener) {\n                document.removeEventListener('touchend', this.touchEndListener);\n                this.touchEndListener = null;\n            }\n        },\n        clear() {\n            this.dragging = false;\n            this.size = null;\n            this.startPos = null;\n            this.prevPanelElement = null;\n            this.nextPanelElement = null;\n            this.prevPanelSize = null;\n            this.nextPanelSize = null;\n            this.gutterElement = null;\n            this.prevPanelIndex = null;\n        },\n        isStateful() {\n            return this.stateKey != null;\n        },\n        getStorage() {\n            switch (this.stateStorage) {\n                case 'local':\n                    return window.localStorage;\n\n                case 'session':\n                    return window.sessionStorage;\n\n                default:\n                    throw new Error(this.stateStorage + ' is not a valid value for the state storage, supported values are \"local\" and \"session\".');\n            }\n        },\n        saveState() {\n            if (isArray(this.panelSizes)) {\n                this.getStorage().setItem(this.stateKey, JSON.stringify(this.panelSizes));\n            }\n        },\n        restoreState() {\n            const storage = this.getStorage();\n            const stateString = storage.getItem(this.stateKey);\n\n            if (stateString) {\n                this.panelSizes = JSON.parse(stateString);\n                let children = [...this.$el.children].filter((child) => child.getAttribute('data-pc-name') === 'splitterpanel');\n\n                children.forEach((child, i) => {\n                    child.style.flexBasis = 'calc(' + this.panelSizes[i] + '% - ' + (this.panels.length - 1) * this.gutterSize + 'px)';\n                });\n\n                return true;\n            }\n\n            return false;\n        },\n        resetState() {\n            this.initializePanels();\n        }\n    },\n    computed: {\n        panels() {\n            const panels = [];\n\n            this.$slots.default().forEach((child) => {\n                if (this.isSplitterPanel(child)) {\n                    panels.push(child);\n                } else if (child.children instanceof Array) {\n                    child.children.forEach((nestedChild) => {\n                        if (this.isSplitterPanel(nestedChild)) {\n                            panels.push(nestedChild);\n                        }\n                    });\n                }\n            });\n\n            return panels;\n        },\n        gutterStyle() {\n            if (this.horizontal) return { width: this.gutterSize + 'px' };\n            else return { height: this.gutterSize + 'px' };\n        },\n        horizontal() {\n            return this.layout === 'horizontal';\n        },\n        getPTOptions() {\n            return {\n                context: {\n                    nested: this.$parentInstance?.nestedState\n                }\n            };\n        },\n        prevPanelMinSize() {\n            const prevPanelMinSize = getVNodeProp(this.panels[this.prevPanelIndex], 'minSize');\n\n            if (this.panels[this.prevPanelIndex].props && prevPanelMinSize) {\n                return prevPanelMinSize;\n            }\n\n            return 0;\n        },\n        nextPanelMinSize() {\n            const nextPanelMinSize = getVNodeProp(this.panels[this.prevPanelIndex + 1], 'minSize');\n\n            if (this.panels[this.prevPanelIndex + 1].props && nextPanelMinSize) {\n                return nextPanelMinSize;\n            }\n\n            return 0;\n        },\n        dataP() {\n            return cn({\n                [this.layout]: this.layout,\n                nested: this.$parentInstance?.nestedState != null\n            });\n        }\n    }\n};\n</script>\n"],
  "mappings": "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",
  "names": ["classes", "root", "_ref", "props", "layout", "gutter", "gutterHandle", "BaseStyle", "extend", "name", "style", "name", "BaseComponent", "props", "layout", "type", "String", "gutterSize", "Number", "stateKey", "stateStorage", "step", "style", "SplitterStyle", "provide", "$pcSplitter", "$parentInstance", "script", "BaseSplitter", "inheritAttrs", "emits", "dragging", "mouseMoveListener", "mouseUpListener", "touchMoveListener", "touchEndListener", "size", "gutterElement", "startPos", "prevPanelElement", "nextPanelElement", "nextPanelSize", "prevPanelSize", "panelSizes", "prevPanelIndex", "timer", "data", "prevSize", "mounted", "initializePanels", "beforeUnmount", "clear", "unbindMouseListeners", "methods", "isSplitterPanel", "child", "_this", "panels", "length", "initialized", "isStateful", "restoreState", "children", "_toConsumableArray", "$el", "filter", "getAttribute", "_panelSizes", "map", "panel", "i", "panelInitialSize", "isNotEmpty", "panelSize", "flexBasis", "parseFloat", "toFixed", "onResizeStart", "event", "index", "isKeyDown", "currentTarget", "target", "parentElement", "horizontal", "getWidth", "getHeight", "pageX", "changedTouches", "pageY", "previousElementSibling", "nextElementSibling", "getOuterWidth", "getOuterHeight", "$emit", "originalEvent", "sizes", "$refs", "gutter", "setAttribute", "onResize", "newPos", "newPrevPanelSize", "newNextPanelSize", "isRTL", "validateResize", "Math", "min", "max", "prevPanelMinSize", "nextPanelMinSize", "onResizeEnd", "saveState", "forEach", "repeat", "setTimer", "_this2", "setInterval", "clearTimer", "clearInterval", "onGutterKeyUp", "onGutterKeyDown", "code", "preventDefault", "onGutterMouseDown", "bindMouseListeners", "onGutterTouchStart", "bindTouchListeners", "onGutterTouchMove", "onGutterTouchEnd", "unbindTouchListeners", "_this3", "document", "addEventListener", "_this4", "resizeEnd", "removeEventListener", "getStorage", "window", "localStorage", "sessionStorage", "Error", "isArray", "setItem", "JSON", "stringify", "_this5", "storage", "stateString", "getItem", "parse", "resetState", "computed", "_this6", "$slots", "push", "Array", "nestedChild", "gutterStyle", "width", "height", "getPTOptions", "_this$$parentInstance", "context", "nested", "nestedState", "getVNodeProp", "dataP", "_this$$parentInstance2", "cn", "_defineProperty", "_openBlock", "_createElementBlock", "_mergeProps", "_ctx", "cx", "$options", "ptmi", "_Fragment", "_renderList", "_createBlock", "_resolveDynamicComponent", "tabindex", "ref", "role", "onMousedown", "$event", "onTouchstart", "onTouchmove", "onTouchend", "ptm", "_createElementVNode", "$data", "onKeyup", "apply", "arguments", "onKeydown", "_hoisted_3"]
}
